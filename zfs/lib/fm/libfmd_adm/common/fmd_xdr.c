/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "fmd_rpc_adm.h"

#ifndef _KERNEL
#include <stdlib.h>
#endif /* !_KERNEL */

#include <fmd_api.h>

bool_t
xdr_fmd_adm_error(XDR *xdrs, fmd_adm_error *objp)
{
	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_rpc_modstat(XDR *xdrs, fmd_rpc_modstat *objp)
{
	if (!xdr_array(xdrs, (char **)&objp->rms_buf.rms_buf_val, (u_int *) &objp->rms_buf.rms_buf_len, ~0,
		sizeof (struct fmd_stat), (xdrproc_t)xdr_fmd_stat))
		return (FALSE);
	if (!xdr_fmd_adm_error(xdrs, &objp->rms_err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_rpc_modinfo(XDR *xdrs, fmd_rpc_modinfo *objp)
{
	fmd_rpc_modinfo *tmp_fmd_rpc_modinfo;
	bool_t more_data = TRUE;
	bool_t first_objp = TRUE;


	if (xdrs->x_op == XDR_DECODE) {

		while (more_data) {
		if (!xdr_string(xdrs, &objp->rmi_name, ~0))
				return (FALSE);
			if (!xdr_string(xdrs, &objp->rmi_desc, ~0))
				return (FALSE);
			if (!xdr_string(xdrs, &objp->rmi_vers, ~0))
				return (FALSE);
			if (!xdr_bool(xdrs, &objp->rmi_faulty))
				return (FALSE);
			if (!xdr_bool(xdrs, &more_data))
				return (FALSE);

			if (!more_data) {
				objp->rmi_next = NULL;
				break;
			}

			if (objp->rmi_next == NULL) {
				objp->rmi_next = (fmd_rpc_modinfo *)
					mem_alloc(sizeof (fmd_rpc_modinfo));
				if (objp->rmi_next == NULL)
					return (FALSE);
				bzero(objp->rmi_next, sizeof (fmd_rpc_modinfo));
			}
			objp = objp->rmi_next;
		}

	} else if (xdrs->x_op == XDR_ENCODE) {

		while (more_data) {
			if (!xdr_string(xdrs, &objp->rmi_name, ~0))
				return (FALSE);
			if (!xdr_string(xdrs, &objp->rmi_desc, ~0))
				return (FALSE);
			if (!xdr_string(xdrs, &objp->rmi_vers, ~0))
				return (FALSE);
			if (!xdr_bool(xdrs, &objp->rmi_faulty))
				return (FALSE);
			objp = objp->rmi_next;
			if (objp == NULL)
				more_data = FALSE;
			if (!xdr_bool(xdrs, &more_data))
				return (FALSE);
		}

	} else {

		while (more_data) {
			if (!xdr_string(xdrs, &objp->rmi_name, ~0))
				return (FALSE);
			if (!xdr_string(xdrs, &objp->rmi_desc, ~0))
				return (FALSE);
			if (!xdr_string(xdrs, &objp->rmi_vers, ~0))
				return (FALSE);
			if (!xdr_bool(xdrs, &objp->rmi_faulty))
				return (FALSE);
			tmp_fmd_rpc_modinfo = objp;
			objp = objp->rmi_next;
			if (objp == NULL)
				more_data = FALSE;
			if (!first_objp)
				mem_free(tmp_fmd_rpc_modinfo, sizeof (fmd_rpc_modinfo));
			else
				first_objp = FALSE;
		}

	}
	return (TRUE);
}

bool_t
xdr_fmd_rpc_modlist(XDR *xdrs, fmd_rpc_modlist *objp)
{
	if (!xdr_fmd_adm_error(xdrs, &objp->rml_err))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->rml_list, sizeof (fmd_rpc_modinfo), (xdrproc_t)xdr_fmd_rpc_modinfo))
		return (FALSE);
	if (!xdr_uint32_t(xdrs, &objp->rml_len))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_rpc_rsrcinfo(XDR *xdrs, fmd_rpc_rsrcinfo *objp)
{
	if (!xdr_string(xdrs, &objp->rri_fmri, ~0))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->rri_uuid, ~0))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->rri_case, ~0))
		return (FALSE);
	if (!xdr_bool(xdrs, &objp->rri_faulty))
		return (FALSE);
	if (!xdr_bool(xdrs, &objp->rri_unusable))
		return (FALSE);
	if (!xdr_bool(xdrs, &objp->rri_invisible))
		return (FALSE);
	if (!xdr_fmd_adm_error(xdrs, &objp->rri_err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_rpc_rsrclist(XDR *xdrs, fmd_rpc_rsrclist *objp)
{
	if (!xdr_bytes(xdrs, (char **)&objp->rrl_buf.rrl_buf_val, (u_int *) &objp->rrl_buf.rrl_buf_len, ~0))
		return (FALSE);
	if (!xdr_uint32_t(xdrs, &objp->rrl_len))
		return (FALSE);
	if (!xdr_uint32_t(xdrs, &objp->rrl_cnt))
		return (FALSE);
	if (!xdr_fmd_adm_error(xdrs, &objp->rrl_err))
		return (FALSE);
	if (!xdr_bool(xdrs, &objp->rrl_all))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_rpc_serdinfo(XDR *xdrs, fmd_rpc_serdinfo *objp)
{
	fmd_rpc_serdinfo *tmp_fmd_rpc_serdinfo;
	bool_t more_data = TRUE;
	bool_t first_objp = TRUE;


	if (xdrs->x_op == XDR_DECODE) {

		while (more_data) {
			if (!xdr_string(xdrs, &objp->rsi_name, ~0))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_delta))
				return (FALSE);
			if (!xdr_uint32_t(xdrs, &objp->rsi_count))
				return (FALSE);
			if (!xdr_bool(xdrs, &objp->rsi_fired))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_n))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_t))
				return (FALSE);
			if (!xdr_bool(xdrs, &more_data))
				return (FALSE);

			if (!more_data) {
				objp->rsi_next = NULL;
				break;
			}

			if (objp->rsi_next == NULL) {
				objp->rsi_next = (fmd_rpc_serdinfo *)
					mem_alloc(sizeof (fmd_rpc_serdinfo));
				if (objp->rsi_next == NULL)
					return (FALSE);
				bzero(objp->rsi_next, sizeof (fmd_rpc_serdinfo));
			}
			objp = objp->rsi_next;
		}

	} else if (xdrs->x_op == XDR_ENCODE) {

		while (more_data) {
			if (!xdr_string(xdrs, &objp->rsi_name, ~0))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_delta))
				return (FALSE);
			if (!xdr_uint32_t(xdrs, &objp->rsi_count))
				return (FALSE);
			if (!xdr_bool(xdrs, &objp->rsi_fired))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_n))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_t))
				return (FALSE);
			objp = objp->rsi_next;
			if (objp == NULL)
				more_data = FALSE;
			if (!xdr_bool(xdrs, &more_data))
				return (FALSE);
		}

	} else {

		while (more_data) {
			if (!xdr_string(xdrs, &objp->rsi_name, ~0))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_delta))
				return (FALSE);
			if (!xdr_uint32_t(xdrs, &objp->rsi_count))
				return (FALSE);
			if (!xdr_bool(xdrs, &objp->rsi_fired))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_n))
				return (FALSE);
			if (!xdr_uint64_t(xdrs, &objp->rsi_t))
				return (FALSE);
			tmp_fmd_rpc_serdinfo = objp;
			objp = objp->rsi_next;
			if (objp == NULL)
				more_data = FALSE;
			if (!first_objp)
				mem_free(tmp_fmd_rpc_serdinfo, sizeof (fmd_rpc_serdinfo));
			else
				first_objp = FALSE;
		}

	}
	return (TRUE);
}

bool_t
xdr_fmd_rpc_serdlist(XDR *xdrs, fmd_rpc_serdlist *objp)
{
	if (!xdr_fmd_adm_error(xdrs, &objp->rsl_err))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->rsl_list, sizeof (fmd_rpc_serdinfo), (xdrproc_t)xdr_fmd_rpc_serdinfo))
		return (FALSE);
	if (!xdr_uint32_t(xdrs, &objp->rsl_len))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_rpc_xprtlist(XDR *xdrs, fmd_rpc_xprtlist *objp)
{
	if (!xdr_array(xdrs, (char **)&objp->rxl_buf.rxl_buf_val, (u_int *) &objp->rxl_buf.rxl_buf_len, ~0,
		sizeof (int32_t), (xdrproc_t)xdr_int32_t))
		return (FALSE);
	if (!xdr_uint32_t(xdrs, &objp->rxl_len))
		return (FALSE);
	if (!xdr_fmd_adm_error(xdrs, &objp->rxl_err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_rpc_caseinfo(XDR *xdrs, fmd_rpc_caseinfo *objp)
{
	if (!xdr_bytes(xdrs, (char **)&objp->rci_evbuf.rci_evbuf_val, (u_int *) &objp->rci_evbuf.rci_evbuf_len, ~0))
		return (FALSE);
	if (!xdr_fmd_adm_error(xdrs, &objp->rci_err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_rpc_caselist(XDR *xdrs, fmd_rpc_caselist *objp)
{
	if (!xdr_bytes(xdrs, (char **)&objp->rcl_buf.rcl_buf_val, (u_int *) &objp->rcl_buf.rcl_buf_len, ~0))
		return (FALSE);
	if (!xdr_uint32_t(xdrs, &objp->rcl_len))
		return (FALSE);
	if (!xdr_uint32_t(xdrs, &objp->rcl_cnt))
		return (FALSE);
	if (!xdr_fmd_adm_error(xdrs, &objp->rcl_err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_adm_serdreset_1_argument(XDR *xdrs, fmd_adm_serdreset_1_argument *objp)
{

	if (!xdr_string(xdrs, &objp->arg1, ~0))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->arg2, ~0))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fmd_adm_rsrcacquit_1_argument(XDR *xdrs, fmd_adm_rsrcacquit_1_argument *objp)
{

	if (!xdr_string(xdrs, &objp->arg1, ~0))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->arg2, ~0))
		return (FALSE);
	return (TRUE);
}
extern void fmd_adm_1(struct svc_req *, SVCXPRT *);
extern void fmd_pceo_1(struct svc_req *, SVCXPRT *);
extern bool_t xdr_fmd_stat(XDR *, struct fmd_stat *);
#undef	RW_READ_HELD
#undef	RW_WRITE_HELD
#undef	RW_LOCK_HELD
#undef	MUTEX_HELD
