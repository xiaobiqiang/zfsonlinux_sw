/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "fmd_rpc_adm.h"
#include <fmd_api.h>

bool_t
xdr_fmd_adm_error (XDR *xdrs, fmd_adm_error *objp)
{
	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_modstat (XDR *xdrs, fmd_rpc_modstat *objp)
{
	 if (!xdr_array (xdrs, (char **)&objp->rms_buf.rms_buf_val, (u_int *) &objp->rms_buf.rms_buf_len, ~0,
		sizeof (struct fmd_stat), (xdrproc_t) xdr_fmd_stat))
		 return FALSE;
	 if (!xdr_fmd_adm_error (xdrs, &objp->rms_err))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_modinfo (XDR *xdrs, fmd_rpc_modinfo *objp)
{
	 if (!xdr_string (xdrs, &objp->rmi_name, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->rmi_desc, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->rmi_vers, ~0))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->rmi_faulty))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->rmi_next, sizeof (fmd_rpc_modinfo), (xdrproc_t) xdr_fmd_rpc_modinfo))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_modlist (XDR *xdrs, fmd_rpc_modlist *objp)
{
	 if (!xdr_fmd_adm_error (xdrs, &objp->rml_err))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->rml_list, sizeof (fmd_rpc_modinfo), (xdrproc_t) xdr_fmd_rpc_modinfo))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->rml_len))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_rsrcinfo (XDR *xdrs, fmd_rpc_rsrcinfo *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_string (xdrs, &objp->rri_fmri, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->rri_uuid, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->rri_case, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_bool (xdrs, &objp->rri_faulty))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->rri_unusable))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->rri_invisible))
				 return FALSE;

		} else {
		IXDR_PUT_BOOL(buf, objp->rri_faulty);
		IXDR_PUT_BOOL(buf, objp->rri_unusable);
		IXDR_PUT_BOOL(buf, objp->rri_invisible);
		}
		 if (!xdr_fmd_adm_error (xdrs, &objp->rri_err))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_string (xdrs, &objp->rri_fmri, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->rri_uuid, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->rri_case, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_bool (xdrs, &objp->rri_faulty))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->rri_unusable))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->rri_invisible))
				 return FALSE;

		} else {
		objp->rri_faulty = IXDR_GET_BOOL(buf);
		objp->rri_unusable = IXDR_GET_BOOL(buf);
		objp->rri_invisible = IXDR_GET_BOOL(buf);
		}
		 if (!xdr_fmd_adm_error (xdrs, &objp->rri_err))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_string (xdrs, &objp->rri_fmri, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->rri_uuid, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->rri_case, ~0))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->rri_faulty))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->rri_unusable))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->rri_invisible))
		 return FALSE;
	 if (!xdr_fmd_adm_error (xdrs, &objp->rri_err))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_rsrclist (XDR *xdrs, fmd_rpc_rsrclist *objp)
{
	 if (!xdr_bytes (xdrs, (char **)&objp->rrl_buf.rrl_buf_val, (u_int *) &objp->rrl_buf.rrl_buf_len, ~0))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->rrl_len))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->rrl_cnt))
		 return FALSE;
	 if (!xdr_fmd_adm_error (xdrs, &objp->rrl_err))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->rrl_all))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_serdinfo (XDR *xdrs, fmd_rpc_serdinfo *objp)
{
	 if (!xdr_string (xdrs, &objp->rsi_name, ~0))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->rsi_delta))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->rsi_count))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->rsi_fired))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->rsi_n))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->rsi_t))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->rsi_next, sizeof (fmd_rpc_serdinfo), (xdrproc_t) xdr_fmd_rpc_serdinfo))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_serdlist (XDR *xdrs, fmd_rpc_serdlist *objp)
{
	 if (!xdr_fmd_adm_error (xdrs, &objp->rsl_err))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->rsl_list, sizeof (fmd_rpc_serdinfo), (xdrproc_t) xdr_fmd_rpc_serdinfo))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->rsl_len))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_xprtlist (XDR *xdrs, fmd_rpc_xprtlist *objp)
{
	 if (!xdr_array (xdrs, (char **)&objp->rxl_buf.rxl_buf_val, (u_int *) &objp->rxl_buf.rxl_buf_len, ~0,
		sizeof (int32_t), (xdrproc_t) xdr_int32_t))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->rxl_len))
		 return FALSE;
	 if (!xdr_fmd_adm_error (xdrs, &objp->rxl_err))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_caseinfo (XDR *xdrs, fmd_rpc_caseinfo *objp)
{
	 if (!xdr_bytes (xdrs, (char **)&objp->rci_evbuf.rci_evbuf_val, (u_int *) &objp->rci_evbuf.rci_evbuf_len, ~0))
		 return FALSE;
	 if (!xdr_fmd_adm_error (xdrs, &objp->rci_err))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_rpc_caselist (XDR *xdrs, fmd_rpc_caselist *objp)
{
	 if (!xdr_bytes (xdrs, (char **)&objp->rcl_buf.rcl_buf_val, (u_int *) &objp->rcl_buf.rcl_buf_len, ~0))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->rcl_len))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->rcl_cnt))
		 return FALSE;
	 if (!xdr_fmd_adm_error (xdrs, &objp->rcl_err))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_adm_serdreset_1_argument (XDR *xdrs, fmd_adm_serdreset_1_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->arg1, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->arg2, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fmd_adm_rsrcacquit_1_argument (XDR *xdrs, fmd_adm_rsrcacquit_1_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->arg1, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->arg2, ~0))
		 return FALSE;
	return TRUE;
}
extern void fmd_adm_1(struct svc_req *, SVCXPRT *);
extern void fmd_pceo_1(struct svc_req *, SVCXPRT *);
extern bool_t xdr_fmd_stat(XDR *, struct fmd_stat *);
#undef RW_READ_HELD
#undef RW_WRITE_HELD
#undef RW_LOCK_HELD
#undef MUTEX_HELD
